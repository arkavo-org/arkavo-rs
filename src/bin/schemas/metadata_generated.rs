#![allow(clippy::all)]
// automatically generated by the FlatBuffers compiler, do not modify

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod arkavo {
    use crate::schemas::entity_generated::arkavo::MediaType;

    extern crate flatbuffers;
    use self::flatbuffers::Follow;

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_RATING_LEVEL: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_RATING_LEVEL: i8 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_RATING_LEVEL: [RatingLevel; 5] = [
        RatingLevel::unused,
        RatingLevel::none,
        RatingLevel::mild,
        RatingLevel::moderate,
        RatingLevel::severe,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct RatingLevel(pub i8);
    #[allow(non_upper_case_globals)]
    impl RatingLevel {
        pub const unused: Self = Self(0);
        pub const none: Self = Self(1);
        pub const mild: Self = Self(2);
        pub const moderate: Self = Self(3);
        pub const severe: Self = Self(4);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::unused,
            Self::none,
            Self::mild,
            Self::moderate,
            Self::severe,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::unused => Some("unused"),
                Self::none => Some("none"),
                Self::mild => Some("mild"),
                Self::moderate => Some("moderate"),
                Self::severe => Some("severe"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for RatingLevel {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for RatingLevel {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for RatingLevel {
        type Output = RatingLevel;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for RatingLevel {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for RatingLevel {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for RatingLevel {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_FORMAT_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_FORMAT_TYPE: i8 = 30;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FORMAT_TYPE: [FormatType; 10] = [
        FormatType::plain,
        FormatType::html,
        FormatType::csv,
        FormatType::xml,
        FormatType::json,
        FormatType::jpeg,
        FormatType::png,
        FormatType::svg,
        FormatType::gif,
        FormatType::pdf,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct FormatType(pub i8);
    #[allow(non_upper_case_globals)]
    impl FormatType {
        pub const plain: Self = Self(0);
        pub const html: Self = Self(1);
        pub const csv: Self = Self(2);
        pub const xml: Self = Self(3);
        pub const json: Self = Self(4);
        pub const jpeg: Self = Self(10);
        pub const png: Self = Self(11);
        pub const svg: Self = Self(12);
        pub const gif: Self = Self(13);
        pub const pdf: Self = Self(30);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 30;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::plain,
            Self::html,
            Self::csv,
            Self::xml,
            Self::json,
            Self::jpeg,
            Self::png,
            Self::svg,
            Self::gif,
            Self::pdf,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::plain => Some("plain"),
                Self::html => Some("html"),
                Self::csv => Some("csv"),
                Self::xml => Some("xml"),
                Self::json => Some("json"),
                Self::jpeg => Some("jpeg"),
                Self::png => Some("png"),
                Self::svg => Some("svg"),
                Self::gif => Some("gif"),
                Self::pdf => Some("pdf"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for FormatType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for FormatType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for FormatType {
        type Output = FormatType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for FormatType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for FormatType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FormatType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_DATA_ENCODING: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_DATA_ENCODING: i8 = 5;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_DATA_ENCODING: [DataEncoding; 6] = [
        DataEncoding::binary,
        DataEncoding::utf8,
        DataEncoding::utf16,
        DataEncoding::ascii,
        DataEncoding::base64,
        DataEncoding::quoted_printable,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct DataEncoding(pub i8);
    #[allow(non_upper_case_globals)]
    impl DataEncoding {
        pub const binary: Self = Self(0);
        pub const utf8: Self = Self(1);
        pub const utf16: Self = Self(2);
        pub const ascii: Self = Self(3);
        pub const base64: Self = Self(4);
        pub const quoted_printable: Self = Self(5);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 5;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::binary,
            Self::utf8,
            Self::utf16,
            Self::ascii,
            Self::base64,
            Self::quoted_printable,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::binary => Some("binary"),
                Self::utf8 => Some("utf8"),
                Self::utf16 => Some("utf16"),
                Self::ascii => Some("ascii"),
                Self::base64 => Some("base64"),
                Self::quoted_printable => Some("quoted_printable"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for DataEncoding {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for DataEncoding {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for DataEncoding {
        type Output = DataEncoding;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for DataEncoding {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for DataEncoding {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for DataEncoding {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ARCHIVE_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ARCHIVE_TYPE: i8 = 7;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ARCHIVE_TYPE: [ArchiveType; 8] = [
        ArchiveType::none,
        ArchiveType::zip,
        ArchiveType::tar,
        ArchiveType::gzip,
        ArchiveType::bzip2,
        ArchiveType::xz,
        ArchiveType::zstd,
        ArchiveType::lz4,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ArchiveType(pub i8);
    #[allow(non_upper_case_globals)]
    impl ArchiveType {
        pub const none: Self = Self(0);
        pub const zip: Self = Self(1);
        pub const tar: Self = Self(2);
        pub const gzip: Self = Self(3);
        pub const bzip2: Self = Self(4);
        pub const xz: Self = Self(5);
        pub const zstd: Self = Self(6);
        pub const lz4: Self = Self(7);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 7;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::none,
            Self::zip,
            Self::tar,
            Self::gzip,
            Self::bzip2,
            Self::xz,
            Self::zstd,
            Self::lz4,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::none => Some("none"),
                Self::zip => Some("zip"),
                Self::tar => Some("tar"),
                Self::gzip => Some("gzip"),
                Self::bzip2 => Some("bzip2"),
                Self::xz => Some("xz"),
                Self::zstd => Some("zstd"),
                Self::lz4 => Some("lz4"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ArchiveType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ArchiveType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ArchiveType {
        type Output = ArchiveType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ArchiveType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ArchiveType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ArchiveType {}
    pub enum RatingOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Rating<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Rating<'a> {
        type Inner = Rating<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Rating<'a> {
        pub const VT_VIOLENT: flatbuffers::VOffsetT = 4;
        pub const VT_SEXUAL: flatbuffers::VOffsetT = 6;
        pub const VT_PROFANE: flatbuffers::VOffsetT = 8;
        pub const VT_SUBSTANCE: flatbuffers::VOffsetT = 10;
        pub const VT_HATE: flatbuffers::VOffsetT = 12;
        pub const VT_HARM: flatbuffers::VOffsetT = 14;
        pub const VT_MATURE: flatbuffers::VOffsetT = 16;
        pub const VT_BULLY: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Rating { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RatingArgs,
        ) -> flatbuffers::WIPOffset<Rating<'bldr>> {
            let mut builder = RatingBuilder::new(_fbb);
            builder.add_bully(args.bully);
            builder.add_mature(args.mature);
            builder.add_harm(args.harm);
            builder.add_hate(args.hate);
            builder.add_substance(args.substance);
            builder.add_profane(args.profane);
            builder.add_sexual(args.sexual);
            builder.add_violent(args.violent);
            builder.finish()
        }

        #[inline]
        pub fn violent(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_VIOLENT, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sexual(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_SEXUAL, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn profane(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_PROFANE, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn substance(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_SUBSTANCE, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn hate(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_HATE, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn harm(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_HARM, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn mature(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_MATURE, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn bully(&self) -> RatingLevel {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RatingLevel>(Rating::VT_BULLY, Some(RatingLevel::unused))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Rating<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            v.visit_table(pos)?
                .visit_field::<RatingLevel>("violent", Self::VT_VIOLENT, false)?
                .visit_field::<RatingLevel>("sexual", Self::VT_SEXUAL, false)?
                .visit_field::<RatingLevel>("profane", Self::VT_PROFANE, false)?
                .visit_field::<RatingLevel>("substance", Self::VT_SUBSTANCE, false)?
                .visit_field::<RatingLevel>("hate", Self::VT_HATE, false)?
                .visit_field::<RatingLevel>("harm", Self::VT_HARM, false)?
                .visit_field::<RatingLevel>("mature", Self::VT_MATURE, false)?
                .visit_field::<RatingLevel>("bully", Self::VT_BULLY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RatingArgs {
        pub violent: RatingLevel,
        pub sexual: RatingLevel,
        pub profane: RatingLevel,
        pub substance: RatingLevel,
        pub hate: RatingLevel,
        pub harm: RatingLevel,
        pub mature: RatingLevel,
        pub bully: RatingLevel,
    }
    impl<'a> Default for RatingArgs {
        #[inline]
        fn default() -> Self {
            RatingArgs {
                violent: RatingLevel::unused,
                sexual: RatingLevel::unused,
                profane: RatingLevel::unused,
                substance: RatingLevel::unused,
                hate: RatingLevel::unused,
                harm: RatingLevel::unused,
                mature: RatingLevel::unused,
                bully: RatingLevel::unused,
            }
        }
    }

    pub struct RatingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RatingBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_violent(&mut self, violent: RatingLevel) {
            self.fbb_
                .push_slot::<RatingLevel>(Rating::VT_VIOLENT, violent, RatingLevel::unused);
        }
        #[inline]
        pub fn add_sexual(&mut self, sexual: RatingLevel) {
            self.fbb_
                .push_slot::<RatingLevel>(Rating::VT_SEXUAL, sexual, RatingLevel::unused);
        }
        #[inline]
        pub fn add_profane(&mut self, profane: RatingLevel) {
            self.fbb_
                .push_slot::<RatingLevel>(Rating::VT_PROFANE, profane, RatingLevel::unused);
        }
        #[inline]
        pub fn add_substance(&mut self, substance: RatingLevel) {
            self.fbb_.push_slot::<RatingLevel>(
                Rating::VT_SUBSTANCE,
                substance,
                RatingLevel::unused,
            );
        }
        #[inline]
        pub fn add_hate(&mut self, hate: RatingLevel) {
            self.fbb_
                .push_slot::<RatingLevel>(Rating::VT_HATE, hate, RatingLevel::unused);
        }
        #[inline]
        pub fn add_harm(&mut self, harm: RatingLevel) {
            self.fbb_
                .push_slot::<RatingLevel>(Rating::VT_HARM, harm, RatingLevel::unused);
        }
        #[inline]
        pub fn add_mature(&mut self, mature: RatingLevel) {
            self.fbb_
                .push_slot::<RatingLevel>(Rating::VT_MATURE, mature, RatingLevel::unused);
        }
        #[inline]
        pub fn add_bully(&mut self, bully: RatingLevel) {
            self.fbb_
                .push_slot::<RatingLevel>(Rating::VT_BULLY, bully, RatingLevel::unused);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RatingBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RatingBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Rating<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Rating<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Rating");
            ds.field("violent", &self.violent());
            ds.field("sexual", &self.sexual());
            ds.field("profane", &self.profane());
            ds.field("substance", &self.substance());
            ds.field("hate", &self.hate());
            ds.field("harm", &self.harm());
            ds.field("mature", &self.mature());
            ds.field("bully", &self.bully());
            ds.finish()
        }
    }
    pub enum PurposeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Purpose<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Purpose<'a> {
        type Inner = Purpose<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Purpose<'a> {
        pub const VT_EDUCATIONAL: flatbuffers::VOffsetT = 4;
        pub const VT_ENTERTAINMENT: flatbuffers::VOffsetT = 6;
        pub const VT_NEWS: flatbuffers::VOffsetT = 8;
        pub const VT_PROMOTIONAL: flatbuffers::VOffsetT = 10;
        pub const VT_PERSONAL: flatbuffers::VOffsetT = 12;
        pub const VT_OPINION: flatbuffers::VOffsetT = 14;
        pub const VT_TRANSACTIONAL: flatbuffers::VOffsetT = 16;
        pub const VT_HARMFUL: flatbuffers::VOffsetT = 18;
        pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Purpose { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PurposeArgs,
        ) -> flatbuffers::WIPOffset<Purpose<'bldr>> {
            let mut builder = PurposeBuilder::new(_fbb);
            builder.add_confidence(args.confidence);
            builder.add_harmful(args.harmful);
            builder.add_transactional(args.transactional);
            builder.add_opinion(args.opinion);
            builder.add_personal(args.personal);
            builder.add_promotional(args.promotional);
            builder.add_news(args.news);
            builder.add_entertainment(args.entertainment);
            builder.add_educational(args.educational);
            builder.finish()
        }

        #[inline]
        pub fn educational(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_EDUCATIONAL, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn entertainment(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_ENTERTAINMENT, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn news(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f32>(Purpose::VT_NEWS, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn promotional(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_PROMOTIONAL, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn personal(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_PERSONAL, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn opinion(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_OPINION, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn transactional(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_TRANSACTIONAL, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn harmful(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_HARMFUL, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn confidence(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(Purpose::VT_CONFIDENCE, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Purpose<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            v.visit_table(pos)?
                .visit_field::<f32>("educational", Self::VT_EDUCATIONAL, false)?
                .visit_field::<f32>("entertainment", Self::VT_ENTERTAINMENT, false)?
                .visit_field::<f32>("news", Self::VT_NEWS, false)?
                .visit_field::<f32>("promotional", Self::VT_PROMOTIONAL, false)?
                .visit_field::<f32>("personal", Self::VT_PERSONAL, false)?
                .visit_field::<f32>("opinion", Self::VT_OPINION, false)?
                .visit_field::<f32>("transactional", Self::VT_TRANSACTIONAL, false)?
                .visit_field::<f32>("harmful", Self::VT_HARMFUL, false)?
                .visit_field::<f32>("confidence", Self::VT_CONFIDENCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PurposeArgs {
        pub educational: f32,
        pub entertainment: f32,
        pub news: f32,
        pub promotional: f32,
        pub personal: f32,
        pub opinion: f32,
        pub transactional: f32,
        pub harmful: f32,
        pub confidence: f32,
    }
    impl<'a> Default for PurposeArgs {
        #[inline]
        fn default() -> Self {
            PurposeArgs {
                educational: 0.0,
                entertainment: 0.0,
                news: 0.0,
                promotional: 0.0,
                personal: 0.0,
                opinion: 0.0,
                transactional: 0.0,
                harmful: 0.0,
                confidence: 0.0,
            }
        }
    }

    pub struct PurposeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PurposeBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_educational(&mut self, educational: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_EDUCATIONAL, educational, 0.0);
        }
        #[inline]
        pub fn add_entertainment(&mut self, entertainment: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_ENTERTAINMENT, entertainment, 0.0);
        }
        #[inline]
        pub fn add_news(&mut self, news: f32) {
            self.fbb_.push_slot::<f32>(Purpose::VT_NEWS, news, 0.0);
        }
        #[inline]
        pub fn add_promotional(&mut self, promotional: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_PROMOTIONAL, promotional, 0.0);
        }
        #[inline]
        pub fn add_personal(&mut self, personal: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_PERSONAL, personal, 0.0);
        }
        #[inline]
        pub fn add_opinion(&mut self, opinion: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_OPINION, opinion, 0.0);
        }
        #[inline]
        pub fn add_transactional(&mut self, transactional: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_TRANSACTIONAL, transactional, 0.0);
        }
        #[inline]
        pub fn add_harmful(&mut self, harmful: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_HARMFUL, harmful, 0.0);
        }
        #[inline]
        pub fn add_confidence(&mut self, confidence: f32) {
            self.fbb_
                .push_slot::<f32>(Purpose::VT_CONFIDENCE, confidence, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PurposeBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PurposeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Purpose<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Purpose<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Purpose");
            ds.field("educational", &self.educational());
            ds.field("entertainment", &self.entertainment());
            ds.field("news", &self.news());
            ds.field("promotional", &self.promotional());
            ds.field("personal", &self.personal());
            ds.field("opinion", &self.opinion());
            ds.field("transactional", &self.transactional());
            ds.field("harmful", &self.harmful());
            ds.field("confidence", &self.confidence());
            ds.finish()
        }
    }
    pub enum FormatInfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FormatInfo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FormatInfo<'a> {
        type Inner = FormatInfo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FormatInfo<'a> {
        pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
        pub const VT_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_PROFILE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FormatInfo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args FormatInfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<FormatInfo<'bldr>> {
            let mut builder = FormatInfoBuilder::new(_fbb);
            if let Some(x) = args.profile {
                builder.add_profile(x);
            }
            if let Some(x) = args.version {
                builder.add_version(x);
            }
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn type_(&self) -> FormatType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<FormatType>(FormatInfo::VT_TYPE_, Some(FormatType::plain))
                    .unwrap()
            }
        }
        #[inline]
        pub fn version(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(FormatInfo::VT_VERSION, None)
            }
        }
        #[inline]
        pub fn profile(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(FormatInfo::VT_PROFILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for FormatInfo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            v.visit_table(pos)?
                .visit_field::<FormatType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "version",
                    Self::VT_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "profile",
                    Self::VT_PROFILE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct FormatInfoArgs<'a> {
        pub type_: FormatType,
        pub version: Option<flatbuffers::WIPOffset<&'a str>>,
        pub profile: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for FormatInfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            FormatInfoArgs {
                type_: FormatType::plain,
                version: None,
                profile: None,
            }
        }
    }

    pub struct FormatInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FormatInfoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_type_(&mut self, type_: FormatType) {
            self.fbb_
                .push_slot::<FormatType>(FormatInfo::VT_TYPE_, type_, FormatType::plain);
        }
        #[inline]
        pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FormatInfo::VT_VERSION, version);
        }
        #[inline]
        pub fn add_profile(&mut self, profile: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FormatInfo::VT_PROFILE, profile);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> FormatInfoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            FormatInfoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FormatInfo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FormatInfo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FormatInfo");
            ds.field("type_", &self.type_());
            ds.field("version", &self.version());
            ds.field("profile", &self.profile());
            ds.finish()
        }
    }
    pub enum ArchiveInfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArchiveInfo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArchiveInfo<'a> {
        type Inner = ArchiveInfo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ArchiveInfo<'a> {
        pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
        pub const VT_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_PROFILE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArchiveInfo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ArchiveInfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArchiveInfo<'bldr>> {
            let mut builder = ArchiveInfoBuilder::new(_fbb);
            if let Some(x) = args.profile {
                builder.add_profile(x);
            }
            if let Some(x) = args.version {
                builder.add_version(x);
            }
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn type_(&self) -> ArchiveType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ArchiveType>(ArchiveInfo::VT_TYPE_, Some(ArchiveType::none))
                    .unwrap()
            }
        }
        #[inline]
        pub fn version(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ArchiveInfo::VT_VERSION, None)
            }
        }
        #[inline]
        pub fn profile(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ArchiveInfo::VT_PROFILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ArchiveInfo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            v.visit_table(pos)?
                .visit_field::<ArchiveType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "version",
                    Self::VT_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "profile",
                    Self::VT_PROFILE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ArchiveInfoArgs<'a> {
        pub type_: ArchiveType,
        pub version: Option<flatbuffers::WIPOffset<&'a str>>,
        pub profile: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ArchiveInfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArchiveInfoArgs {
                type_: ArchiveType::none,
                version: None,
                profile: None,
            }
        }
    }

    pub struct ArchiveInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArchiveInfoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_type_(&mut self, type_: ArchiveType) {
            self.fbb_
                .push_slot::<ArchiveType>(ArchiveInfo::VT_TYPE_, type_, ArchiveType::none);
        }
        #[inline]
        pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ArchiveInfo::VT_VERSION, version);
        }
        #[inline]
        pub fn add_profile(&mut self, profile: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ArchiveInfo::VT_PROFILE, profile);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ArchiveInfoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ArchiveInfoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArchiveInfo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArchiveInfo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArchiveInfo");
            ds.field("type_", &self.type_());
            ds.field("version", &self.version());
            ds.field("profile", &self.profile());
            ds.finish()
        }
    }
    pub enum ContentFormatOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ContentFormat<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ContentFormat<'a> {
        type Inner = ContentFormat<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ContentFormat<'a> {
        pub const VT_MEDIA_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 6;
        pub const VT_FORMAT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ContentFormat { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ContentFormatArgs<'args>,
        ) -> flatbuffers::WIPOffset<ContentFormat<'bldr>> {
            let mut builder = ContentFormatBuilder::new(_fbb);
            if let Some(x) = args.format {
                builder.add_format(x);
            }
            builder.add_data_encoding(args.data_encoding);
            builder.add_media_type(args.media_type);
            builder.finish()
        }

        #[inline]
        pub fn media_type(&self) -> MediaType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<MediaType>(ContentFormat::VT_MEDIA_TYPE, Some(MediaType::unused))
                    .unwrap()
            }
        }
        #[inline]
        pub fn data_encoding(&self) -> DataEncoding {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<DataEncoding>(
                        ContentFormat::VT_DATA_ENCODING,
                        Some(DataEncoding::binary),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn format(&self) -> Option<FormatInfo<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<FormatInfo>>(ContentFormat::VT_FORMAT, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ContentFormat<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            v.visit_table(pos)?
                .visit_field::<MediaType>("media_type", Self::VT_MEDIA_TYPE, false)?
                .visit_field::<DataEncoding>("data_encoding", Self::VT_DATA_ENCODING, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<FormatInfo>>(
                    "format",
                    Self::VT_FORMAT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ContentFormatArgs<'a> {
        pub media_type: MediaType,
        pub data_encoding: DataEncoding,
        pub format: Option<flatbuffers::WIPOffset<FormatInfo<'a>>>,
    }
    impl<'a> Default for ContentFormatArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContentFormatArgs {
                media_type: MediaType::unused,
                data_encoding: DataEncoding::binary,
                format: None,
            }
        }
    }

    pub struct ContentFormatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentFormatBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_media_type(&mut self, media_type: MediaType) {
            self.fbb_.push_slot::<MediaType>(
                ContentFormat::VT_MEDIA_TYPE,
                media_type,
                MediaType::unused,
            );
        }
        #[inline]
        pub fn add_data_encoding(&mut self, data_encoding: DataEncoding) {
            self.fbb_.push_slot::<DataEncoding>(
                ContentFormat::VT_DATA_ENCODING,
                data_encoding,
                DataEncoding::binary,
            );
        }
        #[inline]
        pub fn add_format(&mut self, format: flatbuffers::WIPOffset<FormatInfo<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<FormatInfo>>(
                    ContentFormat::VT_FORMAT,
                    format,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ContentFormatBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ContentFormatBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ContentFormat<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ContentFormat<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ContentFormat");
            ds.field("media_type", &self.media_type());
            ds.field("data_encoding", &self.data_encoding());
            ds.field("format", &self.format());
            ds.finish()
        }
    }
    pub enum MetadataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Metadata<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
        type Inner = Metadata<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Metadata<'a> {
        pub const VT_CREATED: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_RELATED: flatbuffers::VOffsetT = 8;
        pub const VT_RATING: flatbuffers::VOffsetT = 10;
        pub const VT_PURPOSE: flatbuffers::VOffsetT = 12;
        pub const VT_TOPICS: flatbuffers::VOffsetT = 14;
        pub const VT_ARCHIVE: flatbuffers::VOffsetT = 16;
        pub const VT_CONTENT: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Metadata { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MetadataArgs<'args>,
        ) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
            let mut builder = MetadataBuilder::new(_fbb);
            builder.add_created(args.created);
            if let Some(x) = args.content {
                builder.add_content(x);
            }
            if let Some(x) = args.archive {
                builder.add_archive(x);
            }
            if let Some(x) = args.topics {
                builder.add_topics(x);
            }
            if let Some(x) = args.purpose {
                builder.add_purpose(x);
            }
            if let Some(x) = args.rating {
                builder.add_rating(x);
            }
            if let Some(x) = args.related {
                builder.add_related(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn created(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Metadata::VT_CREATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Metadata::VT_ID,
                        None,
                    )
            }
        }
        #[inline]
        pub fn related(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Metadata::VT_RELATED,
                        None,
                    )
            }
        }
        #[inline]
        pub fn rating(&self) -> Option<Rating<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Rating>>(Metadata::VT_RATING, None)
            }
        }
        #[inline]
        pub fn purpose(&self) -> Option<Purpose<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Purpose>>(Metadata::VT_PURPOSE, None)
            }
        }
        #[inline]
        pub fn topics(&self) -> Option<flatbuffers::Vector<'a, u32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        Metadata::VT_TOPICS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn archive(&self) -> Option<ArchiveInfo<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ArchiveInfo>>(Metadata::VT_ARCHIVE, None)
            }
        }
        #[inline]
        pub fn content(&self) -> Option<ContentFormat<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ContentFormat>>(Metadata::VT_CONTENT, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Metadata<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            v.visit_table(pos)?
                .visit_field::<i64>("created", Self::VT_CREATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "id",
                    Self::VT_ID,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "related",
                    Self::VT_RELATED,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Rating>>(
                    "rating",
                    Self::VT_RATING,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Purpose>>(
                    "purpose",
                    Self::VT_PURPOSE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                    "topics",
                    Self::VT_TOPICS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<ArchiveInfo>>(
                    "archive",
                    Self::VT_ARCHIVE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<ContentFormat>>(
                    "content",
                    Self::VT_CONTENT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MetadataArgs<'a> {
        pub created: i64,
        pub id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub related: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub rating: Option<flatbuffers::WIPOffset<Rating<'a>>>,
        pub purpose: Option<flatbuffers::WIPOffset<Purpose<'a>>>,
        pub topics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        pub archive: Option<flatbuffers::WIPOffset<ArchiveInfo<'a>>>,
        pub content: Option<flatbuffers::WIPOffset<ContentFormat<'a>>>,
    }
    impl<'a> Default for MetadataArgs<'a> {
        #[inline]
        fn default() -> Self {
            MetadataArgs {
                created: 0,
                id: None,
                related: None,
                rating: None,
                purpose: None,
                topics: None,
                archive: None,
                content: None,
            }
        }
    }

    pub struct MetadataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_created(&mut self, created: i64) {
            self.fbb_.push_slot::<i64>(Metadata::VT_CREATED, created, 0);
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_ID, id);
        }
        #[inline]
        pub fn add_related(
            &mut self,
            related: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_RELATED, related);
        }
        #[inline]
        pub fn add_rating(&mut self, rating: flatbuffers::WIPOffset<Rating<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Rating>>(Metadata::VT_RATING, rating);
        }
        #[inline]
        pub fn add_purpose(&mut self, purpose: flatbuffers::WIPOffset<Purpose<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Purpose>>(Metadata::VT_PURPOSE, purpose);
        }
        #[inline]
        pub fn add_topics(&mut self, topics: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_TOPICS, topics);
        }
        #[inline]
        pub fn add_archive(&mut self, archive: flatbuffers::WIPOffset<ArchiveInfo<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ArchiveInfo>>(
                    Metadata::VT_ARCHIVE,
                    archive,
                );
        }
        #[inline]
        pub fn add_content(&mut self, content: flatbuffers::WIPOffset<ContentFormat<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ContentFormat>>(
                    Metadata::VT_CONTENT,
                    content,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MetadataBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MetadataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Metadata<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Metadata");
            ds.field("created", &self.created());
            ds.field("id", &self.id());
            ds.field("related", &self.related());
            ds.field("rating", &self.rating());
            ds.field("purpose", &self.purpose());
            ds.field("topics", &self.topics());
            ds.field("archive", &self.archive());
            ds.field("content", &self.content());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Metadata`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_metadata_unchecked`.
    pub fn root_as_metadata(buf: &[u8]) -> Result<Metadata, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Metadata>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Metadata` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_metadata_unchecked`.
    pub fn size_prefixed_root_as_metadata(
        buf: &[u8],
    ) -> Result<Metadata, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Metadata>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Metadata` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_metadata_unchecked`.
    pub fn root_as_metadata_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Metadata<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Metadata<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Metadata` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_metadata_unchecked`.
    pub fn size_prefixed_root_as_metadata_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Metadata<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Metadata<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Metadata and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Metadata`.
    pub unsafe fn root_as_metadata_unchecked(buf: &[u8]) -> Metadata {
        flatbuffers::root_unchecked::<Metadata>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Metadata and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Metadata`.
    pub unsafe fn size_prefixed_root_as_metadata_unchecked(buf: &[u8]) -> Metadata {
        flatbuffers::size_prefixed_root_unchecked::<Metadata>(buf)
    }
    #[inline]
    pub fn finish_metadata_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Metadata<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_metadata_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Metadata<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod Arkavo
